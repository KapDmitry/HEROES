# Анализ алгоритма метода GeneratePreset

## 1. **Описание алгоритма**
Метод `generate` создает армию из списка юнитов, не превышая заданный лимит очков (`maxPoints`). Алгоритм выполняет следующие шаги:

1. Сортирует список юнитов по их эффективности, где эффективность определяется как:

   efficiency = BaseAttack/Cost + Health/Cost

   Сортировка производится по убыванию эффективности.

2. В цикле:
    - Выбирает юнита из отсортированного списка.
    - Добавляет копии юнита в армию, пока не исчерпан лимит очков (`maxPoints`) или пока количество копий юнита не превысит 11.
    - Для каждого юнита генерирует уникальные координаты, проверяя, что они не пересекаются с уже занятыми.

3. Возвращает армию с созданным списком юнитов и оставшимися очками.

---

## 2. **Алгоритмическая сложность**

### **Сортировка списка юнитов**
- Сортировка списка `unitList` производится с использованием компаратора, который вычисляет эффективность для каждого юнита:
    - Вычисление эффективности одного юнита: \( O(1) \).
    - Количество юнитов в списке: \( n \).
    - Временная сложность сортировки:
      O(n  log n).

### **Основной цикл по юнитам**
- В худшем случае алгоритм проходит по всем юнитам в списке `unitList` (\( n \)) и добавляет копии юнитов в армию.
- Для каждого юнита:
    - Максимальное количество добавляемых копий: min(11, maxPoints} / unit.getCost()), что в среднем ограничивается константой 11.
    - Для каждой копии вызывается метод `generateUniqueCoordinates`.

#### **Метод `generateUniqueCoordinates`**
- Метод генерирует случайные координаты и проверяет их уникальность.
- В среднем число попыток для генерации уникальных координат можно считать константным, так как пространство координат ( 3 * 21 = 63 ) достаточно мало.
- Сложность генерации одной координаты: \( O(1) \).

#### **Добавление юнитов в армию**
- Для каждого юнита в армии создаётся новый объект, что имеет сложность \( O(1) \) на каждую копию.
- Добавление \( k \) копий для \( n \) юнитов в худшем случае имеет сложность \( O(n * k) \), где \( k = 11 \), что эквивалентно \( O(n) \).

### **Общая сложность основного цикла**
- Основной цикл добавляет \( n \) юнитов, каждый из которых обрабатывается за \( O(1) \) для генерации координат и создания экземпляра.
- Сложность основного цикла:

  O(n * 11) = O(n).
  

---

## 3. **Итоговая сложность**
Сложность всех этапов:
1. Сортировка списка юнитов: \( O(n * log n) \).
2. Основной цикл: \( O(n) \).
3. Генерация уникальных координат: \( O(n) \).

Итоговая временная сложность:

O(n * log n).


---




# Анализ метода SimulateBattle

## 1. **Описание алгоритма**
Алгоритм симуляции битвы выполняет следующие шаги:

1. Создаёт список всех юнитов из двух армий (`playerUnits` и `computerUnits`).
2. Сортирует список всех юнитов по убыванию значения `baseAttack`.
3. Выполняет цикл:
    - Проверяет, есть ли живые юниты в обеих армиях.
    - Для каждого юнита в отсортированном списке:
        - Если юнит мёртв, он пропускается.
        - Если жив, то:
            - Атакует цель.
            - Производится логирование атаки через `printBattleLog`.

Битва завершается, когда одна из армий полностью уничтожена.

---

## 2. **Алгоритмическая сложность**

### **Инициализация списка юнитов**
- Создание объединённого списка `allUnits` из двух списков (`playerUnits` и `computerUnits`):
    - Пусть `n` - общее количество юнитов в обеих армиях.
    - Сложность: \( O(n) \) (линейное копирование элементов).

### **Сортировка списка юнитов**
- Сортировка списка `allUnits` с использованием `Comparator.comparingInt`:
    - Размер списка равен \( n \).
    - Временная сложность Timsort: \( O((n) \cdot \log(n) \).

### **Основной цикл**
- Основной цикл продолжается, пока в обеих армиях есть живые юниты.
- В каждом проходе цикла:
    - Проверка, есть ли живые юниты в армиях:
        - `hasAliveUnits(playerUnits)` и `hasAliveUnits(computerUnits)` проверяют наличие живых юнитов за \( O(n) \)  соответственно.
        - Общая сложность проверки: \( O(n) \).
    - Итерация по всем юнитам в списке `allUnits`:
        - Проверка `unit.isAlive()` для каждого юнита: \( O(n) \).
        - Атака и логирование:
            - Методы `unit.getProgram().attack()` и `printBattleLog.printBattleLog()` считаются константными, то есть \( O(1) \).

Таким образом, сложность одной итерации цикла:

O(n) + O(n) = O(n).


### **Количество итераций цикла**
- В худшем случае цикл выполняется k раз, где  k  — общее количество атак в битве.
-  k >= n , так как каждая атака может убить одного юнита, а общее количество юнитов равно \( n\), при этом за одну атаку могут и не убить ни одного юнита, поэтому k зависит от n.

### **Общая сложность**
- Суммарная сложность основного цикла:
  k * O(n) = O((n)^2).
---

## 3. **Итоговая сложность**
Сложность всех этапов алгоритма:
1. Создание объединённого списка: \( O(n) \).
2. Сортировка: \( O((n) log(n)) \).
3. Основной цикл: \( O((n)^2) \).

Так как наиболее затратной частью является основной цикл, общая временная сложность алгоритма:

O((n)^2).

---


# Анализ алгоритма метода SuitableForAttackUnitsFinderImpl

## 1. **Описание алгоритма с учетом ограничений**
Условия:
- Число рядов (`m`) всегда равно 3.
- Общее число юнитов во всех рядах равно \( N \).

Метод `getSuitableUnits` выполняет следующие шаги:

1. **Сбор позиций всех живых юнитов:**
    - Проходит по всем юнитам во всех рядах и добавляет позиции живых юнитов в множество `aliveUnitPositions`.

2. **Проверка каждого юнита:**
    - Для каждого живого юнита проверяет:
        - Если юнит принадлежит атакуемой левой армии, он подходит, если не закрыт слева.
        - Если юнит принадлежит атакуемой правой армии, он подходит, если не закрыт справа.
    - Подходящие юниты добавляются в список `suitableUnits`.

---

## 2. **Алгоритмическая сложность**

### **Сбор позиций всех живых юнитов**
- Алгоритм проходит по всем юнитам в трёх рядах:
    - Общее число юнитов \( N \).
    - Временная сложность:
      O(N)

### **Проверка каждого юнита**
- Алгоритм снова проходит по всем \( N \) юнитам:
    - Для каждого юнита, если он жив, проверяет, закрыт ли он слева или справа, используя метод `checkPos`.
    - Проверка координаты в `HashSet` выполняется за \( O(1) \).
    - Временная сложность:
      O(N)

### **Общая сложность**
- Сбор позиций всех живых юнитов: \( O(N) \).
- Проверка каждого юнита: \( O(N) \).
- Общая временная сложность:
  O(N) + O(N) = O(N).

---

## 3. **Итоговая сложность**
С учетом того, что число рядов фиксировано ( m = 3 ), алгоритм линейно зависит от общего количества юнитов  N. Итоговая временная сложность:

O(N)

---


# Анализ алгоритма метода UnitTargetPathFinder

## 1. **Описание алгоритма**
Метод `getTargetPath` реализует поиск пути (pathfinding) на сетке размером ( WIDTH  * HEIGHT ). Используется алгоритм поиска в ширину (BFS), чтобы найти кратчайший путь от атакующего юнита до целевой позиции, обходя препятствия.

### Условия задачи
В задаче указано, что для атакующего юнита с координатами ( x = 1 ), ( y = 2 ) и атакуемого юнита ( x = 0 ), \( y = 0 \), результатом должен стать путь:
[Edge(1, 2), Edge(1, 1), Edge(1, 0)].

Это значает, что юниты могут перемещаться только в четырёх направлениях: вверх, вниз, влево, вправо. Однако, алгоритм может быть модифицирован для перемещения по диагоналям без изменения временной сложности, что делает его гибким для других правил.

---

### Основные шаги алгоритма:
1. **Инициализация:**
    - Создаётся двумерный массив `visited` для отслеживания посещённых клеток.
    - Координаты всех занятых клеток (где стоят юниты из `existingUnitList`) помечаются как посещённые.
    - Начальная точка (координаты атакующего юнита) добавляется в очередь `queue`.

2. **Поиск пути (BFS):**
    - BFS обходит клетки, начиная с точки атакующего юнита, и добавляет в очередь все соседние клетки, которые находятся в пределах сетки и не посещены.
    - Когда целевая клетка (координаты атакуемого юнита) достигнута, путь восстанавливается с использованием карты `parentMap`.

3. **Реконструкция пути:**
    - Путь от атакующего юнита до цели восстанавливается в обратном порядке с помощью `parentMap` и возвращается.

---

## 2. **Алгоритмическая сложность**

### 2.1. Сложность BFS
Алгоритм BFS работает со сложностью:

O(V + E),

где:
- \( V \) — количество вершин (в данном случае клеток сетки), ( V = WIDTH * HEIGHT ).
- \( E \) — количество рёбер (соседних клеток), для прямых перемещений \( E <= 4 * WIDTH * HEIGHT \), поскольку каждая клетка может иметь максимум 4 соседа.

Итак, сложность BFS:

O(V + E) = O(WIDTH * HEIGHT + 4 * WIDTH * HEIGHT) = O(WIDTH * HEIGHT).


### 2.2. Инициализация
1. **Маркировка занятых клеток:**
    - Проход по списку юнитов (`existingUnitList`), пометка занятых клеток в `visited`.
    - Пусть \( k \) — количество юнитов.
    - Сложность:
      
      O(k).

2. **Инициализация BFS:**
    - Создание очереди и добавление начальной точки: \( O(1) \).

### 2.3. Реконструкция пути
1. **Восстановление пути из `parentMap`:**
    - Пусть длина пути составляет \( p \) шагов.
    - Сложность:
      O(p).
---

## 3. **Общая сложность**
Общая временная сложность алгоритма:
O(k) + O(WIDTH * HEIGHT) + O(p).


При ( WIDTH * HEIGHT >> k ) и ( WIDTH * HEIGHT >> p ), итоговая сложность:

O(WIDTH * HEIGHT).


